# Persistence Support
Implementing persistence with momentum is very easy. You just need to specify two parameters in root widget config and implement json serialization in the models. Anything else is done by the library automatically.

## Configure
You have to specify both `persistSave` and `persistGet` parameter on `Momentum` root widget.

- `persistSave` is a `Future<bool>` function parameter, so it should be marked as `async`. If the function returns `true`, it means the state was successfully saved. It's up to you how you handle it with your storage provider but with `SharedPreferences`, the save function returns a `bool` already so we can use it directly. Both the `key` and `value` parameter are string so `.setString(...)` method is used. `BuildContext` is also provided so if the storage provider requires context you can use it easily.
  ```dart
  Momentum(
    // ...
    persistSave: (context, key, value) async {
      var sharedPref = await SharedPreferences.getInstance();
      var result = await sharedPref.setString(key, value);
      return result;
    },
    // ...
  )
  ```

- `persistGet` is a `Future<String>` and should be marked `async` too. With `SharedPreferences` you just need to call `.getString(key)` directly, return it, and you're done.
  ```dart
  Momentum(
    // ...
    persistGet: (context, key) async {
      var sharedPref = await SharedPreferences.getInstance();
      var result = sharedPref.getString(key);
      return result;
    },
    // ...
  )
  ```

!> `key` and `value` are automatically generated by momentum **IF** the json serialization are valid and working.

!> `SharedPreferences` is used in this example but always remember you can use **any** storage provider.

## JSON Serialization
The *models* must implement json serialization. You need to be familiar with `.toJson()` and `.fromJson(...)` method to understand this section. Read more about it [here](https://flutter.dev/docs/development/data-and-backend/json).

With momentum, implementing `.toJson()` is the same way with how you do it traditionally. **BUT** with `.fromJson` it is quite different.

- Implementing `.toJson()` looks like this:
```dart
  class ExampleModel extends MomentumModel<ExampleController> {

    // ...

    final int firstProperty;
    final String secondProperty;

    // ...

    Map<String, dynamic> toJson() {
      return {
        'firstProperty': firstProperty,
        'secondProperty': secondProperty,
      };
    }

    // ...
  }
```

- Now, for `.fromJson`, it is different but it still very easy to write:
```dart
  class ExampleModel extends MomentumModel<ExampleController> {

    // ...

    final int firstProperty;
    final String secondProperty;

    // ...

    ExampleModel fromJson(Map<String, dynamic> json) {
      return ExampleModel(
        controller,
        firstProperty: json['firstProperty'],
        secondProperty: json['secondProperty'],
      );
    }

    // ...
  }
```
There are two differences. First, the `.fromJson` is an instance member not *static* or *factory* method which is the traditional way. Second, the `controller` part in the constructor. That is the reason why it should be instance member and not static, you wouldn't be able to access the `controller` property otherwise.

!> `Momentum` will throw an error and stacktrace link if the json serializer fails. You can easily track them.

## How does it Work?
- Everytime you call `model.update(...)`, `persistSave` will be called automatically *after*. So you might want to apply some optimization in here.
- For `persistGet`, it will only be called when the app starts. If persisted model is available, the `init()` values inside controller will be overwritten.

- `persistSave` will use the `.toJson()` serialization.
- `persistGet` will use the `.fromJson(...)` serialization.