# Persistence Support
Implementing persistence with momentum is very easy. You just need to specify two parameters in root widget config and implement json serialization in the models. Anything else is done by the library automatically.

## Configure
You have to specify both `persistSave` and `persistGet` parameter on `Momentum` root widget.

- `persistSave` is a `Future<bool>` function parameter, so it should be marked as `async`. If the function returns `true`, it means the state was successfully saved. It's up to you how you handle it with your storage provider but with `SharedPreferences`, the save function returns a `bool` already so we can use it directly. Both the `key` and `value` parameter are string so `.setString(...)` method is used. `BuildContext` is also provided so if the storage provider requires context you can use it easily.
  ```dart
  Momentum(
    // ...
    persistSave: (context, key, value) async {
      var sharedPref = await SharedPreferences.getInstance();
      var result = await sharedPref.setString(key, value);
      return result;
    },
    // ...
  )
  ```

- `persistGet` is a `Future<String>` and should be marked `async` too. With `SharedPreferences` you just need to call `.getString(key)` directly, return it, and you're done.
  ```dart
  Momentum(
    // ...
    persistGet: (context, key) async {
      var sharedPref = await SharedPreferences.getInstance();
      var result = sharedPref.getString(key);
      return result;
    },
    // ...
  )
  ```

!> `key` and `value` are automatically generated by momentum **IF** the json serialization are valid and working.

!> `SharedPreferences` is used in this example but always remember you can use **any** storage provider.

## JSON Serialization
The *models* must implement json serialization. You need to be familiar with `.toJson()` and `.fromJson(...)` method to understand this section. Read more about it [here](https://flutter.dev/docs/development/data-and-backend/json).

With momentum, implementing `.toJson()` is the same way with how you do it traditionally. **BUT** with `.fromJson` it is quite different.

- Implementing `.toJson()` looks like this:
```dart
  class ExampleModel extends MomentumModel<ExampleController> {

    // ...

    final int firstProperty;
    final String secondProperty;

    // ...

    Map<String, dynamic> toJson() {
      return {
        'firstProperty': firstProperty,
        'secondProperty': secondProperty,
      };
    }

    // ...
  }
```

- Now, for `.fromJson`, it is different but it still very easy to write:
```dart
  class ExampleModel extends MomentumModel<ExampleController> {

    // ...

    final int firstProperty;
    final String secondProperty;

    // ...

    ExampleModel fromJson(Map<String, dynamic> json) {
      return ExampleModel(
        controller,
        firstProperty: json['firstProperty'],
        secondProperty: json['secondProperty'],
      );
    }

    // ...
  }
```
There are two differences. First, the `.fromJson` is an instance member not *static* or *factory* method which is the traditional way. Second, the `controller` part in the constructor. That is the reason why it should be instance member and not static, you wouldn't be able to access the `controller` property otherwise.

!> `Momentum` will throw an error and stacktrace link if the json serializer fails. You can easily track them.

## Persistent Navigation
Momentum has a custom router system for persisting the app's navigation. But first, What is persistent navigation or routing?
- When you terminate the app and reopen it again, you'll be back at the same page where you left off.
- Navigation history is also saved.
- If you pressed system back button, you'll be navigated to the correct previous page based on the navigation activity.
- There is currently no library that does this out of the box. Momentum is first.
- The featured example app for momentum implements this feature. See this [preview](/?id=preview).

- #### Guide
  1. You need to instantiate the built in service called `Router` in momentum root widget in `services` parameter. The `Router` class has a parameter which is a list of widgets and those widgets must be a screen or page type widgets:
  ```dart
    Momentum(
      // ...
      services: [
        // ...
        Router([
          PageA(),
          PageB(),
          PageC(),
          // and so on
        ]),
      ],
      // ...
    )
  ```
  2. Properly react to system back button using `RouterPage` widget. This widget is like `WillPopScope` which means you can override the pop behavior using `onWillPop` parameter:
  ```dart
    class PageB extends StatefulWidget { ... }

    class _PageBState extends State<PageB> {

      @override
      Widget build(BuildContext context) {
        return RouterPage(
          // onWillPop: ...
          child: Scaffold(
            body: ...
          ),
        );
      }
    }
  ```
  3. Now you can navigate between pages using `Router.goto(...)` and `Router.pop(context)`:
  ```dart
    // "PageC". use type not an instance or string route name.
    Router.goto(context, PageC);

    // Go back to previous page
    Router.pop(context);
  ```
- As you can see on the guide section above, you navigate between pages using *types* not instance or string route name. That is one of best part with momentum.

## How does it Work?
- Everytime you call `model.update(...)`, `persistSave` will be called automatically *after*. So you might want to apply some optimization in here.
- For `persistGet`, it will only be called when the app starts. If persisted model is available, the `init()` values inside controller will be overwritten.

- `persistSave` will use the `.toJson()` serialization.
- `persistGet` will use the `.fromJson(...)` serialization.

- `Router` uses both `persistSave` and `persistGet`. So if you want to use it you need to implement those two function parameter.
- Persistent router saves the `indexes` of the pages. If you added new page or reordered the items in the list inside `Router` constructor, it is recommended to clear the data of the app to avoid errors.